#!/usr/bin/env perl
use warnings;
use strict;
use 5.018;

use Data::Dump qw(pp);
MAIN: {
    my $filename = $ARGV[0];
    my $pkgname = $ARGV[1];
    my $list = parseFile( $filename );
    # warn "list: ", pp( $list );
    my $file = genCode($pkgname, $list);
    print $file;
}

sub genCode {
    # golang
    my ($pkgname, $list) = @_;
    my $line = genFileHead( $pkgname);
    for ( @$list ){
         $line .= genFuncation( @$_ );
    }
    return $line;
}

sub genFuncation {
    my ($funcName, $nums) = @_;
    my $line = "func Get$funcName (t float64) float64 {\n";
    $line .= genFuncationBody($nums);
    $line .= "}\n\n";
    return $line;
}

sub genFileHead {
    my ($pkgname) = @_;
qq|
/*
   EARTH - VSOP87 Series Version D
   HELIOCENTRIC DYNAMICAL ECLIPTIC AND EQUINOX OF THE DATE
   Spherical (L,B,R) Coordinates

   Series Validity Span: 2000 BC < Date < 6000 AD
   Theoretical accuracy over span: Â±1 arc sec

   L = Longitude in radians
   B = Latitude in radians
   R = Radius vector in AU (Astronomical Units)

   t = (JD - 2451545) / 365250

   VSOP87 Functions Source Code
   Generated By The VSOP87 Source Code Generator Tool

   Ref:
   Planetary Theories in Rectangular and Spherical Variables
   VSOP87 Solutions
   Pierre Bretagnon, Gerard Francou
   Journal of Astronomy & Astrophysics
   vol. 202, p309-p315
   1988

   Source code provided under the provisions of the
   GNU General Public License (GPL), version 3.
   http://www.gnu.org/licenses/gpl.html
*/

package $pkgname

import (
    "math"
)

|;
}

sub genFuncationBody {
    my $nums = $_[0];
    my $tab = ' ' x 4;
    my $line = "${tab}var result float64 = 0.0\n";

    for ( @$nums ) {
        my ($A,$B,$C) = @$_;
        if ( $C == 0.0 ){
            my $const = $A * cos($B);
            # my $cosB = cos($B);
            # $line .= "${tab}// A = $A  B = $B cos(B) = $cosB\n";
            my $sign = $const > 0 ? '+' : '-';
            $line .= "${tab}result $sign= $const\n";
        } else {
            $line .= "${tab}result += $A * math.Cos($B + $C * t)\n";
        }
    }
    $line .= "${tab}return result\n";
    return $line;
}


sub parseFile {
    my $filename = $_[0];
    open my $fh, '<', $filename
        or die $!;
    my $list = parse($fh);
    close $fh;
    return $list;
}

sub parse {
    my ($fh) = @_;
    my @list;
    while ( defined (my $line = <$fh>) ) {
        my ($planet, $arg, $num, $length) = parseTitle( $line );
        my $needParse = ($planet eq "Earth");
        my $list = parseNumberLines($fh, $length, $needParse);
        if ( $needParse ) {
            # return 1, $arg, $list;
            push @list, [$planet . $arg . $num , $list];
        }
    }
    return \@list;
}

sub parseNumberLines {
    my ($fh, $count, $needParse) = @_;
    if ($needParse){
        my @list;
        for ( 1 .. $count ) {
            my $line = <$fh>;
            push @list, parseNumbers( $line );
        }
        return \@list;
    }
    else {
        # no need parse
        # skip $count lines
        scalar <$fh> for 1..$count;
        return undef;
    }
}


sub parseTitle {
    my ($line) = @_;
    my ($planet, $arg, $num, $length) = split /\s/, $line,4;
    $length = int($length);
    # $num = int($num)
    return $planet, $arg, $num, $length;
}

sub parseNumbers {
    my ($line) = @_;
    my ($a,$b,$c) = split /\s/, $line, 3;
    $a += 0;
    $b += 0;
    $c += 0;
    return [$a,$b,$c];
}
